import streamlit as st
import io
import base64
from typing import Optional, Dict, Any
from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.style import WD_STYLE_TYPE
from docx.oxml.ns import qn
from docx.oxml import OxmlElement

from models.business_logic import BusinessLogic, TestScript

class DocExporter:
    """Component for exporting business logic and test scripts as Word documents."""
    
    def __init__(self):
        """Initialize the document exporter component."""
        pass
    
    def _create_business_logic_doc(self, business_logic: BusinessLogic) -> Document:
        """
        Create a Word document for the business logic.
        
        Args:
            business_logic: The business logic to export
            
        Returns:
            Document: The generated Word document
        """
        doc = Document()
        
        # Add document styles
        self._add_document_styles(doc)
        
        # Add cover page
        self._add_cover_page(doc, 
                             f"{business_logic.program_name} Business Logic",
                             f"Program Type: {business_logic.program_type}",
                             "Generated by IDMS Program Analyzer")
        
        # Add table of contents
        self._add_toc(doc)
        
        # Add page break
        doc.add_page_break()
        
        # Add program information section
        doc.add_heading("Program Information", level=1)
        table = doc.add_table(rows=3, cols=2)
        table.style = "Table Grid"
        
        # Set the column widths
        for cell in table.columns[0].cells:
            cell.width = Inches(1.5)
        
        # Add program details
        cells = table.rows[0].cells
        cells[0].text = "Program Name"
        cells[1].text = business_logic.program_name
        
        cells = table.rows[1].cells
        cells[0].text = "Program Type"
        cells[1].text = business_logic.program_type
        
        cells = table.rows[2].cells
        cells[0].text = "Program Purpose"
        cells[1].text = business_logic.program_purpose
        
        # Add paragraph spacing
        doc.add_paragraph()
        
        # Add core business rules section
        doc.add_heading("Core Business Rules", level=1)
        
        if not business_logic.core_rules:
            doc.add_paragraph("No core business rules identified.")
        else:
            for rule in business_logic.core_rules:
                doc.add_heading(rule.rule_id, level=2)
                
                p = doc.add_paragraph()
                p.add_run("Description: ").bold = True
                p.add_run(rule.description)
                
                p = doc.add_paragraph()
                p.add_run("Implementation: ").bold = True
                p.add_run(rule.implementation)
                
                # Add separator
                doc.add_paragraph()
        
        # Add validations section
        doc.add_heading("Validations", level=1)
        
        if not business_logic.validations:
            doc.add_paragraph("No validations identified.")
        else:
            # Create a table for validations
            validation_table = doc.add_table(rows=1, cols=3)
            validation_table.style = "Table Grid"
            
            # Add header row
            header_cells = validation_table.rows[0].cells
            header_cells[0].text = "Field"
            header_cells[1].text = "Validation Rule"
            header_cells[2].text = "Error Handling"
            
            # Apply formatting to header row
            for cell in header_cells:
                for paragraph in cell.paragraphs:
                    for run in paragraph.runs:
                        run.bold = True
                    paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Add validation rows
            for validation in business_logic.validations:
                row_cells = validation_table.add_row().cells
                row_cells[0].text = validation.field
                row_cells[1].text = validation.rule
                row_cells[2].text = validation.error_handling or "N/A"
        
        # Add paragraph spacing
        doc.add_paragraph()
        
        # Add special cases section
        doc.add_heading("Special Cases", level=1)
        
        if not business_logic.special_cases:
            doc.add_paragraph("No special cases identified.")
        else:
            for i, case in enumerate(business_logic.special_cases):
                # Create a table for each special case
                case_table = doc.add_table(rows=3, cols=2)
                case_table.style = "Light Shading Accent 1"
                
                cells = case_table.rows[0].cells
                cells[0].text = "Condition"
                cells[0].width = Inches(1.5)
                cells[1].text = case.condition
                
                cells = case_table.rows[1].cells
                cells[0].text = "Handling"
                cells[1].text = case.handling
                
                cells = case_table.rows[2].cells
                cells[0].text = "Notes"
                cells[1].text = case.notes if case.notes else "N/A"
                
                # Apply formatting to header cells
                for row in case_table.rows:
                    cell = row.cells[0]
                    for paragraph in cell.paragraphs:
                        for run in paragraph.runs:
                            run.bold = True
                
                # Add space between tables
                if i < len(business_logic.special_cases) - 1:
                    doc.add_paragraph()
        
        # Add paragraph spacing
        doc.add_paragraph()
        
        # Add integration points section
        doc.add_heading("Integration Points", level=1)
        
        if not business_logic.integration_points:
            doc.add_paragraph("No integration points identified.")
        else:
            for point in business_logic.integration_points:
                doc.add_heading(point.name, level=2)
                
                table = doc.add_table(rows=3, cols=2)
                table.style = "Light List Accent 2"
                
                cells = table.rows[0].cells
                cells[0].text = "Type"
                cells[0].width = Inches(1.5)
                cells[1].text = point.type
                
                cells = table.rows[1].cells
                cells[0].text = "Direction"
                cells[1].text = point.direction
                
                cells = table.rows[2].cells
                cells[0].text = "Description"
                cells[1].text = point.description
                
                # Apply formatting to header cells
                for row in table.rows:
                    cell = row.cells[0]
                    for paragraph in cell.paragraphs:
                        for run in paragraph.runs:
                            run.bold = True
                
                # Add separator
                doc.add_paragraph()
        
        # Add additional notes section
        if business_logic.additional_notes:
            doc.add_heading("Additional Notes", level=1)
            doc.add_paragraph(business_logic.additional_notes)
        
        # Add footer
        self._add_footer(doc, f"IDMS Program Analyzer - Business Logic for {business_logic.program_name}")
        
        return doc
    
    def _create_test_script_doc(self, test_script: TestScript) -> Document:
        """
        Create a Word document for the test script.
        
        Args:
            test_script: The test script to export
            
        Returns:
            Document: The generated Word document
        """
        doc = Document()
        
        # Add document styles
        self._add_document_styles(doc)
        
        # Add cover page
        self._add_cover_page(doc, 
                             f"Test Script for {test_script.program_name}",
                             f"Total Test Cases: {len(test_script.test_cases)}",
                             "Generated by IDMS Program Analyzer")
        
        # Add table of contents
        self._add_toc(doc)
        
        # Add page break
        doc.add_page_break()
        
        # Add introduction
        doc.add_heading("Introduction", level=1)
        doc.add_paragraph(f"This document contains test cases for the {test_script.program_name} program. " +
                         "Each test case includes a description, prerequisites, test data, steps, and expected results.")
        
        # Add test case summary
        doc.add_heading("Test Case Summary", level=1)
        
        # Create a summary table
        summary_table = doc.add_table(rows=1, cols=3)
        summary_table.style = "Table Grid"
        
        # Add header row
        header_cells = summary_table.rows[0].cells
        header_cells[0].text = "Test ID"
        header_cells[1].text = "Test Title"
        header_cells[2].text = "Description"
        
        # Apply formatting to header row
        for cell in header_cells:
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.bold = True
                paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Add summary rows
        for test_case in test_script.test_cases:
            row_cells = summary_table.add_row().cells
            row_cells[0].text = test_case.test_id
            row_cells[1].text = test_case.title
            row_cells[2].text = test_case.description
        
        doc.add_paragraph()
        
        # Add each test case
        doc.add_heading("Test Cases", level=1)
        
        for i, test_case in enumerate(test_script.test_cases):
            # Add each test case with a page break before (except the first one)
            if i > 0:
                doc.add_page_break()
                
            doc.add_heading(f"Test Case: {test_case.test_id}", level=2)
            doc.add_heading(test_case.title, level=3)
            
            # Add a styled box for the description
            self._add_text_box(doc, "Description", test_case.description)
            
            # Prerequisites
            doc.add_heading("Prerequisites", level=4)
            if not test_case.prerequisites:
                doc.add_paragraph("None")
            else:
                for prereq in test_case.prerequisites:
                    p = doc.add_paragraph()
                    p.style = "List Bullet"
                    p.add_run(prereq)
            
            # Test Data
            doc.add_heading("Test Data", level=4)
            if not test_case.test_data:
                doc.add_paragraph("None")
            else:
                # Create a table for test data
                data_table = doc.add_table(rows=1, cols=2)
                data_table.style = "Light Grid Accent 3"
                
                # Add header row
                header_cells = data_table.rows[0].cells
                header_cells[0].text = "Field"
                header_cells[1].text = "Value"
                
                # Apply formatting to header row
                for cell in header_cells:
                    for paragraph in cell.paragraphs:
                        for run in paragraph.runs:
                            run.bold = True
                        paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
                
                # Add data rows
                for key, value in test_case.test_data.items():
                    row_cells = data_table.add_row().cells
                    row_cells[0].text = key
                    row_cells[1].text = str(value)
            
            # Test Steps
            doc.add_heading("Test Steps", level=4)
            for i, step in enumerate(test_case.steps, 1):
                p = doc.add_paragraph()
                p.style = "List Number"
                p.add_run(step)
            
            # Expected Results
            doc.add_heading("Expected Results", level=4)
            for result in test_case.expected_results:
                p = doc.add_paragraph()
                p.style = "List Bullet"
                p.add_run(result)
            
            # Related Rules
            if test_case.related_rules:
                doc.add_heading("Related Business Rules", level=4)
                p = doc.add_paragraph()
                p.add_run(", ".join(test_case.related_rules))
        
        # Add footer
        self._add_footer(doc, f"IDMS Program Analyzer - Test Script for {test_script.program_name}")
        
        return doc
    
    def _add_document_styles(self, doc: Document) -> None:
        """
        Add custom styles to the document.
        
        Args:
            doc: The document to add styles to
        """
        # Define a title style
        title_style = doc.styles.add_style('Title Style', WD_STYLE_TYPE.PARAGRAPH)
        font = title_style.font
        font.name = 'Calibri'
        font.size = Pt(28)
        font.bold = True
        font.color.rgb = RGBColor(0, 0, 128)  # Navy blue
        
        # Define a heading 1 style
        h1_style = doc.styles.add_style('Heading 1 Style', WD_STYLE_TYPE.PARAGRAPH)
        font = h1_style.font
        font.name = 'Calibri'
        font.size = Pt(16)
        font.bold = True
        font.color.rgb = RGBColor(0, 51, 102)  # Dark blue
        
        # Define a heading 2 style
        h2_style = doc.styles.add_style('Heading 2 Style', WD_STYLE_TYPE.PARAGRAPH)
        font = h2_style.font
        font.name = 'Calibri'
        font.size = Pt(14)
        font.bold = True
        font.color.rgb = RGBColor(0, 102, 153)  # Medium blue
        
        # Define a heading 3 style
        h3_style = doc.styles.add_style('Heading 3 Style', WD_STYLE_TYPE.PARAGRAPH)
        font = h3_style.font
        font.name = 'Calibri'
        font.size = Pt(12)
        font.bold = True
        font.color.rgb = RGBColor(0, 153, 204)  # Light blue
        
        # Define a heading 4 style
        h4_style = doc.styles.add_style('Heading 4 Style', WD_STYLE_TYPE.PARAGRAPH)
        font = h4_style.font
        font.name = 'Calibri'
        font.size = Pt(11)
        font.bold = True
        font.italic = True
        font.color.rgb = RGBColor(0, 153, 204)  # Light blue
        
        # Apply the styles to the document's default styles
        doc.styles['Title'].font.color.rgb = RGBColor(0, 0, 128)
        for i in range(1, 5):
            if f'Heading {i}' in doc.styles:
                doc.styles[f'Heading {i}'].font.color.rgb = RGBColor(0, 51 * i, 102 + 25 * i)
    
    def _add_cover_page(self, doc: Document, title: str, subtitle: str, footer_text: str) -> None:
        """
        Add a cover page to the document.
        
        Args:
            doc: The document to add the cover page to
            title: The document title
            subtitle: The document subtitle
            footer_text: The footer text
        """
        # Add a page break to ensure we start on a new page
        if len(doc.paragraphs) > 0:
            doc.add_page_break()
        
        # Add some vertical space
        for _ in range(10):
            doc.add_paragraph()
        
        # Add title
        title_para = doc.add_paragraph()
        title_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        title_run = title_para.add_run(title)
        title_run.font.size = Pt(26)
        title_run.font.bold = True
        title_run.font.color.rgb = RGBColor(0, 0, 128)  # Navy blue
        
        # Add subtitle
        subtitle_para = doc.add_paragraph()
        subtitle_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        subtitle_run = subtitle_para.add_run(subtitle)
        subtitle_run.font.size = Pt(16)
        subtitle_run.font.italic = True
        
        # Add some vertical space
        for _ in range(5):
            doc.add_paragraph()
        
        # Add date and time
        import datetime
        date_para = doc.add_paragraph()
        date_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        date_run = date_para.add_run(f"Generated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}")
        date_run.font.size = Pt(12)
        
        # Add footer text
        footer_para = doc.add_paragraph()
        footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        footer_run = footer_para.add_run(footer_text)
        footer_run.font.size = Pt(10)
        
        # Add page break after cover page
        doc.add_page_break()
    
    def _add_toc(self, doc: Document) -> None:
        """
        Add a table of contents to the document.
        
        Args:
            doc: The document to add the table of contents to
        """
        doc.add_heading("Table of Contents", level=1)
        
        # Add a paragraph for the TOC field
        p = doc.add_paragraph()
        
        # Create the TOC field
        run = p.add_run()
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'begin')
        run._element.append(fldChar)
        
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'TOC \\o "1-3" \\h \\z \\u'
        run._element.append(instrText)
        
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'separate')
        run._element.append(fldChar)
        
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'end')
        run._element.append(fldChar)
    
    def _add_text_box(self, doc: Document, title: str, content: str) -> None:
        """
        Add a styled text box to the document.
        
        Args:
            doc: The document to add the text box to
            title: The title of the text box
            content: The content of the text box
        """
        # Create a table to simulate a text box
        table = doc.add_table(rows=1, cols=1)
        table.style = "Light Shading"
        
        # Add content to the cell
        cell = table.rows[0].cells[0]
        
        # Add title
        title_p = cell.paragraphs[0]
        title_run = title_p.add_run(f"{title}: ")
        title_run.bold = True
        
        # Add content
        content_run = title_p.add_run(content)
        
        # Add spacing after the text box
        doc.add_paragraph()
    
    def _add_footer(self, doc: Document, footer_text: str) -> None:
        """
        Add a footer to the document.
        
        Args:
            doc: The document to add the footer to
            footer_text: The text to add to the footer
        """
        section = doc.sections[0]
        footer = section.footer
        footer_para = footer.paragraphs[0]
        footer_para.text = footer_text
        footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Add page numbers
        footer_para.add_run("\nPage ")
        
        run = footer_para.add_run()
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'begin')
        run._element.append(fldChar)
        
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'PAGE'
        run._element.append(instrText)
        
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'separate')
        run._element.append(fldChar)
        
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'end')
        run._element.append(fldChar)
        
        footer_para.add_run(" of ")
        
        run = footer_para.add_run()
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'begin')
        run._element.append(fldChar)
        
        instrText = OxmlElement('w:instrText')
        instrText.set(qn('xml:space'), 'preserve')
        instrText.text = 'NUMPAGES'
        run._element.append(instrText)
        
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'separate')
        run._element.append(fldChar)
        
        fldChar = OxmlElement('w:fldChar')
        fldChar.set(qn('w:fldCharType'), 'end')
        run._element.append(fldChar)
    
    def _get_download_link(self, doc: Document, filename: str) -> str:
        """
        Generate a download link for the document.
        
        Args:
            doc: The document to download
            filename: The filename to use
            
        Returns:
            str: HTML download link
        """
        # Save the document to a bytes buffer
        buffer = io.BytesIO()
        doc.save(buffer)
        buffer.seek(0)
        
        # Create a download link
        b64 = base64.b64encode(buffer.read()).decode()
        href = f'data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,{b64}'
        
        return f'<a href="{href}" download="{filename}" class="btn">Download {filename}</a>'
    
    def render(self, business_logic: Optional[BusinessLogic], test_script: Optional[TestScript]) -> None:
        """
        Render the document exporter UI.
        
        Args:
            business_logic: The business logic to export
            test_script: The test script to export
        """
        st.markdown("## Export Documents")
        st.write("Download the generated business logic and test scripts as Word documents.")
        
        # Add CSS for better looking download buttons
        st.markdown("""
        <style>
        .btn {
            display: inline-block;
            padding: 0.5rem 1rem;
            background-color: #4CAF50;
            color: white;
            text-align: center;
            text-decoration: none;
            font-size: 16px;
            border-radius: 4px;
            transition: background-color 0.3s;
            margin: 10px 0;
        }
        .btn:hover {
            background-color: #45a049;
        }
        </style>
        """, unsafe_allow_html=True)
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("Business Logic Document")
            if business_logic:
                # Create the document
                doc = self._create_business_logic_doc(business_logic)
                
                # Create a download button
                download_link = self._get_download_link(
                    doc, 
                    f"{business_logic.program_name}_Business_Logic.docx"
                )
                
                st.markdown(download_link, unsafe_allow_html=True)
                
                st.info("""
                The business logic document includes:
                - Program information
                - Core business rules
                - Validations
                - Special cases
                - Integration points
                - Additional notes
                """)
            else:
                st.warning("Please validate business logic first.")
        
        with col2:
            st.subheader("Test Script Document")
            if test_script:
                # Create the document
                doc = self._create_test_script_doc(test_script)
                
                # Create a download button
                download_link = self._get_download_link(
                    doc, 
                    f"{test_script.program_name}_Test_Script.docx"
                )
                
                st.markdown(download_link, unsafe_allow_html=True)
                
                st.info(f"""
                The test script document includes {len(test_script.test_cases)} test cases with:
                - Test descriptions
                - Prerequisites
                - Test data
                - Step-by-step instructions
                - Expected results
                """)
            else:
                st.warning("Please generate test scripts first.")
        
        # Add section for exporting both documents as a package
        if business_logic and test_script:
            st.subheader("Export Complete Package")
            st.write("Download both documents in a single click:")
            
            # Create the documents
            logic_doc = self._create_business_logic_doc(business_logic)
            test_doc = self._create_test_script_doc(test_script)
            
            # Add download buttons in a centered layout
            col1, col2, col3 = st.columns([1, 2, 1])
            with col2:
                st.markdown(
                    self._get_download_link(
                        logic_doc, 
                        f"{business_logic.program_name}_Business_Logic.docx"
                    ), 
                    unsafe_allow_html=True
                )
                
                st.markdown(
                    self._get_download_link(
                        test_doc, 
                        f"{test_script.program_name}_Test_Script.docx"
                    ), 
                    unsafe_allow_html=True
                )
            
            # Add a tip
            st.info("""
            **Tip:** These documents are fully editable! After downloading, you can:
            - Update formatting or styling
            - Add company branding
            - Incorporate additional details
            - Share with your team
            """)

# Example usage in a Streamlit app:
#
# import streamlit as st
# from components.file_uploader import FileUploader
# from components.logic_extractor import LogicExtractor
# from components.logic_validator import LogicValidator
# from components.test_generator import TestGenerator
# from components.doc_exporter import DocExporter
# from utils.llm_utils import LLMUtils
#
# def main():
#     st.title("IDMS Program Analyzer")
#     
#     # Initialize session state
#     if "business_logic" not in st.session_state:
#         st.session_state.business_logic = None
#     if "validated_logic" not in st.session_state:
#         st.session_state.validated_logic = None
#     if "test_script" not in st.session_state:
#         st.session_state.test_script = None
#     
#     # Initialize utilities
#     llm_utils = LLMUtils()
#     
#     # Initialize and render the file uploader
#     uploader = FileUploader()
#     file_info = uploader.render()
#     
#     # If a valid file was uploaded, show program stats and offer extraction
#     if file_info["valid"]:
#         uploader.render_program_stats(file_info["content"])
#         
#         # Initialize and render the logic extractor
#         extractor = LogicExtractor(llm_utils)
#         business_logic = extractor.render(file_info)
#         
#         if business_logic:
#             st.session_state.business_logic = business_logic
#         
#         # If business logic exists, show the validator
#         if st.session_state.business_logic:
#             validator = LogicValidator()
#             validated_logic = validator.render(st.session_state.business_logic)
#             
#             if validated_logic:
#                 st.session_state.validated_logic = validated_logic
#                 
#                 # If validated logic exists, show the test generator
#                 if st.session_state.validated_logic:
#                     test_generator = TestGenerator(llm_utils)
#                     
#                     if st.session_state.test_script:
#                         # Render with existing test script
#                         test_script = test_generator.render_with_existing(
#                             st.session_state.validated_logic,
#                             st.session_state.test_script
#                         )
#                     else:
#                         # Generate new test script
#                         test_script = test_generator.render(st.session_state.validated_logic)
#                     
#                     if test_script:
#                         st.session_state.test_script = test_script
#                         
#                         # Show document exporter
#                         exporter = DocExporter()
#                         exporter.render(
#                             st.session_state.validated_logic,
#                             st.session_state.test_script
#                         )
#
# if __name__ == "__main__":
#     main()
